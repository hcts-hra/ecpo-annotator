<link rel="import" href="../bower_components/polymer/polymer-element.html">

<link rel="import" href="../bower_components/polymer/lib/elements/dom-if.html">
<link rel="import" href="../bower_components/polymer/lib/elements/custom-style.html">

<!--<link rel="import" href="../bower_components/paper-spinner/paper-spinner-lite.html">-->
<link rel="import" href="../bower_components/paper-styles/color.html">
<link rel="import" href="../bower_components/paper-styles/typography.html">
<link rel="import" href="../bower_components/iron-icon/iron-icon.html">
<link rel="import" href="../bower_components/iron-icons/iron-icons.html">
<link rel="import" href="../bower_components/iron-icons/editor-icons.html">
<link rel="import" href="../bower_components/iron-icons/maps-icons.html">
<link rel="import" href="../bower_components/iron-icons/device-icons.html">
<link rel="import" href="../bower_components/iron-icons/hardware-icons.html">
<link rel="import" href="../bower_components/iron-icons/image-icons.html">
<!--<link rel="import" href="../bower_components/paper-icon-button/paper-icon-button.html">-->
<link rel="import" href="../bower_components/toggle-icon/toggle-icon.html">

<!--<link rel="import" href="bower_components/web-animations-js/web-animations.html">-->
<!--<link rel="import" href="image-loader.html">-->

<script src="../bower_components/openseadragon/built-openseadragon/openseadragon/openseadragon.min.js"></script>
<script src="OpenseadragonFabricjsOverlay/openseadragon-fabricjs-overlay.js"></script>
<script src="../bower_components/fabric.js/dist/fabric.js"></script>

<!--
`img-pan-zoom` Image pan zoom element

Images are preloaded by `img-loader` and a spinner is shown until loaded
Deep Zoom Images are supported

### Styling

Custom property | Description | Default
----------------|-------------|----------
`--img-pan-zoom-spinner` | Mixin applied to spinner |
`--img-pan-zoom-spinner-color` | Spinner color | `#2196F3`
`--img-pan-zoom-spinner-width` | Spinner width | `5px`

### Credits

<a href="https://openseadragon.github.io">openSeadragon</a>


@demo demo/index.html
-->

<dom-module id="existdb-image-annotator">
    <template>
        <style>
            :host {
                display: block;
                position: relative;
                width: 100%;
                height: 100%;
                --toggle-icon-buttons: {
                    padding: 8px;
                    width: 40px;
                    height: 40px;
                };
                @apply(--paper-font-common-base);
            }

            toggle-icon {
                --toggle-icon: {
                    color: var(--paper-grey-700);
                };
            }

            .checked-blue {
                --toggle-icon-checked: {
                    color: var(--paper-blue-500);
                };
            }

            paper-icon-button{
                color: var(--paper-grey-700);
            }

            paper-spinner-lite {
                opacity: 0;
                display: block;
                transition: opacity 700ms;
                position: absolute;
                margin: auto;
                top: 0;
                left: 0;
                bottom: 0;
                right: 0;
                z-index: 1;
                height: 70px;
                width: 70px;
                --paper-spinner-color: var(--img-pan-zoom-spinner-color, #2196F3);
                --paper-spinner-stroke-width: var(--img-pan-zoom-spinner-width, 5px);
                @apply(--img-pan-zoom-spinner);
            }

            paper-spinner-lite[active] {
                opacity: 1;
            }

            [hidden] {
                display: none;
            }

            .buttonBar {
                width: 100%;
                height: 40px;
                z-index: -1;
                background: white;
                border-bottom: 1px solid;
            }

            .divider {
                display: inline;
                margin: 0 8px;
                border-right: thin solid var(--paper-grey-500);
            }

            .cursorposition {
                font-size: 0.8rem;
                font-family: monospace;
            }

            :host ::slotted(.logout){
                float:right;
            }

            :host ::slotted(#osd-slot-container){
                position: relative;
                top: 0;
                left: 0;
                height: calc(100% - 41px);
                width: 100%; 
            }

            .displayMode{
                position: absolute;
                top:13px;
                right:60px;
                font-size:14px;
                color:var(--paper-blue-500);
            }
        </style>

        <div class="buttonBar">
            <!-- Openseadragon controls -->
            <paper-icon-button id="zoomIn" icon="zoom-in" title="zoom in"></paper-icon-button>
            <paper-icon-button id="zoomOut" icon="zoom-out" title="zoom out"></paper-icon-button>
            <paper-icon-button id="homeBtn" icon="home" title="home" on-click="_onHome"></paper-icon-button>
            <paper-icon-button id="fullScreen" icon="fullscreen" title="fullscreen"
                               on-click="_onFullScreen"></paper-icon-button>
            <toggle-icon id="panzoom"
                         icon="pan-tool"
                         title="mouse pan and zoom"
                         class="checked-blue mode-selector" on-click="_panzoom"></toggle-icon>

            <div class="divider"></div>

            <toggle-icon id="selectMode"
                         icon="tap"
                         title="select"
                         animation="flip-horizontal"
                         class="checked-blue mode-selector" on-click="_select"></toggle-icon>

            <toggle-icon id="fillMode"
                         icon="invert-colors"
                         animation="flip-horizontal"
                         on-click="_fillMode"
                         class="checked-blue"></toggle-icon>

            <toggle-icon id="groupMode"
                        icon="groupmode"
                        animation="flip-horizontal"
                        class="checked-blue mode-selector"
                        on-click="_group"></toggle-icon>

            <div class="divider"></div>
            <!-- TODO: hide if active selection -->
            <toggle-icon id="rectMode"
                         icon="image:crop-3-2"
                         title="add rectangle"
                         on-click="_createRect"
                         class="checked-blue mode-selector"></toggle-icon>

            <toggle-icon id="circleMode"
                         icon="image:panorama-fish-eye"
                         title="add circle"
                         on-click="_createCircle"
                         class="checked-blue mode-selector"></toggle-icon>

            <toggle-icon id="polyMode"
                          icon="device:signal-cellular-null"
                          title="add polygon"
                          on-click="_createPolygon"
                          class="checked-blue mode-selector"></toggle-icon>

            <div class="divider"></div>
            <!-- TODO: show if active selection -->
            <toggle-icon id="editMode"
                         icon="editnodes"
                         title="edit"
                         on-click="_edit"
                         animation="flip-horizontal"
                         class="checked-blue mode-selector"
                         disabled="[[_noShapeSelected(selectedShape)]]"></toggle-icon>

            <paper-icon-button icon="remove-circle" title="remove shape" on-click="_removeShape"></paper-icon-button>

            <div class="divider"></div>

            <!--
            <span class="cursorposition" id="cursorWindowPosition"></span>
            <div class="divider"></div>
            <span class="cursorposition" id="cursorContainerPosition"></span>
            <div class="divider"></div>
            <span class="cursorposition" id="cursorImagePosition"></span>
            <div class="divider"></div>
            <span class="cursorposition" id="cursorViewportPosition"></span>
            -->

            <div style="width:0;height:0;border:0;display:inline;" tabindex="0" id="focusDummy"></div>
            <slot name="logout"></slot>
            <div class="displayMode">mode:[[mode]]</div>
        </div>
        <!-- Openseadragon is attached to host inside a container element -->
        <slot></slot>

    </template>
    <script>
        class ExistdbImageAnnotator extends Polymer.Element {
            static get is() {
                return 'existdb-image-annotator';
            }

            static get properties() {
                return {
                    // Image source
                    src: {
                        type: String,
                        observer: '_srcChanged'
                    },
                    // Set to true if you are using a deep zoom image
                    dzi: {
                        type: Boolean,
                        value: false
                    },
                    // Fade in new items added to the viewer
                    fadeIn: {
                        type: Boolean,
                        value: true
                    },
                    // loading
                    loading: {
                        type: Boolean,
                        readonly: true,
                        notify: true
                    },
                    // hides spinner
                    hideSpinner: {
                        type: Boolean,
                        value: false
                    },
                    // loaded
                    loaded: {
                        type: Boolean,
                        readonly: true,
                        notify: true,
                        observer: "_loadedChanged"
                    },
                    // Set to false to prevent the appearance of the default navigation controls. Note that if set to false, the customs buttons set by the options zoomInButton, zoomOutButton etc, are rendered inactive.
                    showNavigationControl: {
                        type: Boolean,
                        value: true
                    },
                    // Set to true to make the navigator minimap appear.
                    showNavigator: {
                        type: Boolean,
                        value: false
                    },
                    // The "zoom distance" per mouse click or touch tap. Note: Setting this to 1.0 effectively disables the click-to-zoom feature (also see gestureSettings[Mouse|Touch|Pen].clickToZoom/dblClickToZoom).
                    zoomPerClick: {
                        type: Number,
                        value: 2.0
                    },
                    // The "zoom distance" per mouse scroll or touch pinch. Note: Setting this to 1.0 effectively disables the mouse-wheel zoom feature (also see gestureSettings[Mouse|Touch|Pen].scrollToZoom}).
                    zoomPerScroll: {
                        type: Number,
                        value: 1.2
                    },
                    // Specifies the animation duration per each OpenSeadragon.Spring which occur when the image is dragged or zoomed.
                    animationTime: {
                        type: Number,
                        value: 1.2
                    },
                    // If true then the 'previous' button will wrap to the last image when viewing the first image and the 'next' button will wrap to the first image when viewing the last image.
                    navPrevNextWrap: {
                        type: Boolean,
                        value: false
                    },
                    // If true then the rotate left/right controls will be displayed as part of the standard controls. This is also subject to the browser support for rotate (e.g. viewer.drawer.canRotate()).
                    showRotationControl: {
                        type: Boolean,
                        value: false
                    },
                    // The minimum percentage ( expressed as a number between 0 and 1 ) of the viewport height or width at which the zoom out will be constrained. Setting it to 0, for example will allow you to zoom out infinity.
                    minZoomImageRatio: {
                        type: Number,
                        value: 1
                    },
                    // The maximum ratio to allow a zoom-in to affect the highest level pixel ratio. This can be set to Infinity to allow 'infinite' zooming into the image though it is less effective visually if the HTML5 Canvas is not availble on the viewing device.
                    maxZoomPixelRatio: {
                        type: Number,
                        value: 1.1
                    },
                    // Constrain during pan
                    constrainDuringPan: {
                        type: Boolean,
                        value: false
                    },
                    // The percentage ( as a number from 0 to 1 ) of the source image which must be kept within the viewport. If the image is dragged beyond that limit, it will 'bounce' back until the minimum visibility ratio is achieved. Setting this to 0 and wrapHorizontal ( or wrapVertical ) to true will provide the effect of an infinitely scrolling viewport.
                    visibilityRatio: {
                        type: Number,
                        value: 1
                    },
                    showZoomControl: {
                        type: Boolean,
                        value: false
                    },
                    showHomeControl: {
                        type: Boolean,
                        value: false
                    },
                    showFullPageControl: {
                        type: Boolean,
                        value: false
                    },
                    preserveViewport: {
                        type: Boolean,
                        value: true
                    },
                    autoHideControls: {
                        type: Boolean,
                        value: true
                    },
                    defaultZoomLevel: {
                        type: Number,
                        value: 0
                    },
                    viewer: {
                        type: Object,
                        value: () => {
                            return {}
                        }
                    },
                    zoom: {
                        type: Number
                    },
                    selectedShape: {
                        type: Object,
                        value: _ => null
                    },
                    fill: {
                        type: Boolean,
                        value: false
                    },
                    mode: {
                        type: String,
                        observer: '_modeChange',
                        notify:true,
                        value: 'navigate' // open seadragon mode
                    },
                    modes: {
                        type: Object,
                        value: {
                            NAVIGATE: 'navigate',
                            SELECT: 'select',
                            GROUP: 'group',
                            CIRCLE: 'circle',
                            RECTANGLE: 'rectangle',
                            POLYGON: 'polygon',
                            EDIT: 'edit'
                        }
                    }
                };
            }

            connectedCallback() {
                super.connectedCallback();

                // const mouseTrackerMoveHandler = this.onMouseTrackerMove.bind(this)
                // const mouseTracker = new OpenSeadragon.MouseTracker({
                //     element: document,
                //     moveHandler: mouseTrackerMoveHandler
                // });

                this.addEventListener('annotator-initialized', function(){
                    console.log('Annotator init');
                    this.init = true;
                    this.mode = this.modes.SELECT;
                    // mouseTracker.setTracking(true)
                });

                // document.addEventListener('shape-created', this._newShapeHandler.bind(this))
                // document.addEventListener('shape-changed', this._changedShapeHandler.bind(this))
                // document.addEventListener('shape-deleted', this._deletedShapeHandler.bind(this))
                document.addEventListener('shape-selected', this._selectedShapeHandler.bind(this))
                this.addEventListener('keydown', this._keyHandler);
                this.$.focusDummy.focus();
            }

            initialize () {
                console.log('initialize');

                let d = document.createElement('div')
                d.id = 'osd-slot-container'
                this.appendChild(d)
                this._initOpenSeadragon();
                console.log('OSD init done');
                this._initFabric();
                this.dispatchEvent(new CustomEvent('annotator-initialized', {}));
            }

            disconnectedCallback() {
                super.disconnectedCallback();
                this.removeEventListener('keypress', this._keyHandler);
            }


            pointToString(type, point) {
                return `${type}: ${point.x.toPrecision(4)}, ${point.y.toPrecision(4)}`;
            }

            onMouseTrackerMove(event) {
                const viewerX = event.position.x;
                const viewerY = event.position.y;
                const windowPoint = new OpenSeadragon.Point(viewerX, viewerY);

                const containerPoint = windowPoint.minus(OpenSeadragon.getElementPosition(this.viewer.element));

                const image1 = this.viewer.world.getItemAt(0);
                const imagePoint = image1.windowToImageCoordinates(windowPoint);

                const viewportPoint = this.viewer.viewport.windowToViewportCoordinates(windowPoint);
                this.$.cursorWindowPosition.innerHTML = this.pointToString('w', windowPoint)
                this.$.cursorContainerPosition.innerHTML = this.pointToString('c', containerPoint)
                this.$.cursorImagePosition.innerHTML = this.pointToString('i', imagePoint)
                this.$.cursorViewportPosition.innerHTML = this.pointToString('v', viewportPoint)
            }

            _initFabric() {
                console.log('_initFabric start');
                const options = {annotator: this};
                this._fabricOverlay = this.viewer.fabricjsOverlay(options);
                console.log('_initFabric done');
            }

            // Init openseadragon
            _initOpenSeadragon() {
                console.log('_initOpenSeadragon');
                const tileSource = this.dzi ? this.src : {
                    type: 'image',
                    url: this.src,
                    buildPyramid: false
                };
                console.log('_initOpenSeadragon');

                this.viewer = OpenSeadragon({
                    element: this.querySelector('#osd-slot-container'),
                    prefixUrl: "/exist/apps/ecpo/bower_components/openseadragon/built-openseadragon/openseadragon/images/",
                    visibilityRatio: this.visibilityRatio,
                    constrainDuringPan: this.constrainDuringPan,
                    showNavigationControl: this.showNavigationControl,
                    showNavigator: this.showNavigator,
                    zoomPerClick: this.zoomPerClick,
                    zoomPerScroll: this.zoomPerScroll,
                    animationTime: this.animationTime,
                    navPrevNextWrap: this.navPrevNextWrap,
                    showRotationControl: this.showRotationControl,
                    minZoomImageRatio: this.minZoomImageRatio,
                    maxZoomPixelRatio: this.maxZoomPixelRatio,
                    showZoomControl: this.showZoomControl,
                    showHomeControl: false,
                    showFullPageControl: false,
                    sequenceMode: true,
                    tileSources: [tileSource],
                    gestureSettingsMouse: {
                        clickToZoom: false
                    },
                    zoomInButton: this.$.zoomIn,
                    zoomOutButton: this.$.zoomOut
                });
                console.log('_initOpenSeadragon end');
            }

            _newShapeHandler(e) {
//                console.log('NEW SHAPE', e.detail.shape)
            }

            _changedShapeHandler(e) {
//                console.log('CHANGED SHAPE', e.detail.shape)
            }

            _deletedShapeHandler(e) {
//                console.log('DELETED SHAPE', e.detail.shape)
            }

            _selectedShapeHandler(e) {
                console.log('SELECTED SHAPE', e.detail.shape)
                this.set('selectedShape', e.detail.shape)
            }

            highlight(shapeId) {
                this._fabricOverlay.highlight(shapeId)
            }

            getZoom() {
                return this.viewer.viewport.getZoom(true);
            }

            // Function to destroy the viewer and clean up everything created by OpenSeadragon.
            destroy() {
                // TODO destroy fabricJSoverlay?
                this.viewer.destroy();
            }

            getPoint() {
//                console.log('getPoint ', OpenSeadragon.Point(0, 0));
                return OpenSeadragon.Point(0, 0);
            }

            getScale() {
                return this.viewer.options._scale
            }

            getBounds() {
                this.viewer.getBounds(true);
            }

            // Zoom in
            zoomIn() {
                // TODO: Replace with native openseadragon zoomIn
                var currentZoom = this.viewer.viewport.getZoom();
                var maxZoom = this.viewer.viewport.getMaxZoom();
                var zoomTo = currentZoom + .7;
                if (zoomTo < maxZoom) {
                    this.viewer.viewport.zoomTo(zoomTo);
                }
            }

            // Zoom out
            zoomOut() {
                // TODO: Replace with openseadragon native zoomOut
                var currentZoom = this.viewer.viewport.getZoom();
                var minZoom = this.viewer.viewport.getMinZoom();
                var zoomTo = currentZoom - .7;
                if (zoomTo > minZoom) {
                    this.viewer.viewport.zoomTo(zoomTo);
                } else {
                    if (minZoom != currentZoom) {
                        this.resetZoom();
                    }
                }
            }

            // reset zoom
            resetZoom() {
                this.viewer.viewport.goHome();
            }

            _srcChanged(newVal, oldVal) {
                console.log('_srcChanged');
                if (!newVal || newVal == '') {return}
                if (!this.init) {
                    return this.initialize();
                }
                if (this.dzi && this.init) {
                    return this._addTiledImage();
                }
   
                this._addImage()
            }

            // // Add loaded images to viewer
            // _loadedChanged() {
            //     if (!this.loaded) { return }
            //     if (!this.init) {
            //         return this._initOpenSeadragon();
            //     }
            //     this._clear()
            //     this._addImage();
            // }

            _addImage() {
                this.viewer.addSimpleImage({url: this.src, index: 0, replace: true});
            }

            _addTiledImage() {
                this.viewer.addTiledImage({tileSource: this.src, index: 0, replace: true});
            }

            _removeShape(e) {
                this._fabricOverlay.remove()
            }

            _logShapes() {
                this._data = this._fabricOverlay.serialize();
            }

            _loadShapes() {
                this._fabricOverlay.load(this._data);
            }

            _clear() {
                this._fabricOverlay.clear();
            }

            _createRect() {
                this.mode = this.modes.RECTANGLE
            }

            _createCircle() {
                this.mode = this.modes.CIRCLE
            }

            _createPolygon() {
                this.mode = this.modes.POLYGON
            }

            _edit() {
                if (this._noShapeSelected(this.selectedShape)) { return }
                this.mode = this.modes.EDIT
            }

            _onHome(e) {
                this._fabricOverlay.deselect();
                this.viewer.viewport.goHome();
                this.viewer.setMouseNavEnabled(true);
                this.mode = this.modes.NAVIGATE
            }

            _panzoom(e) {
                this.mode = this.modes.NAVIGATE
            }

            _select(e) {
                this.mode = this.modes.SELECT
            }

            /*
            code stolen from osd and routed to this.viewer.
             */
            _onFullScreen(e) {
                if (this.viewer.isFullPage() && !this.viewer.isFullScreen()) {
                    // Is fullPage but not fullScreen
                    this.viewer.setFullPage(false);
                } else {
                    this.viewer.setFullScreen(!this.viewer.isFullPage());
                }
                // correct for no mouseout event on change
                if (this.viewer.buttons) {
                    this.viewer.buttons.emulateExit();
                }
                this.viewer.fullPageButton.element.focus();
                if (this.viewer.viewport) {
                    this.viewer.viewport.applyConstraints();
                }
            }

            _modeChange(newVal, oldVal) {
                console.log('_modeChanged ', newVal, oldVal);

                if (!this.init) { return }
                if (newVal === oldVal) { return }

                const mapMode2Toggle = {}
                mapMode2Toggle[this.modes.NAVIGATE] = this.$.panzoom
                mapMode2Toggle[this.modes.SELECT] = this.$.selectMode
                mapMode2Toggle[this.modes.RECTANGLE] = this.$.rectMode
                mapMode2Toggle[this.modes.CIRCLE] = this.$.circleMode
                mapMode2Toggle[this.modes.POLYGON] = this.$.polyMode
                mapMode2Toggle[this.modes.EDIT] = this.$.editMode
                mapMode2Toggle[this.modes.GROUP] = this.$.groupMode

                mapMode2Toggle[oldVal].checked = false
                mapMode2Toggle[newVal].checked = true

                const mode = newVal;
                switch (mode) {
                    case this.modes.RECTANGLE:
                    case this.modes.CIRCLE:
                    case this.modes.POLYGON:
                        this.viewer.setMouseNavEnabled(false);
                        this._fabricOverlay.deselect();
                        this._fabricOverlay.lockAllObjects(true);
                        break;
                    case this.modes.SELECT:
                        // always call switchFillMode to switch back to shape colors
                        this._fabricOverlay.switchFillMode(this.fill);
                        this.viewer.setMouseNavEnabled(false);
                        this._fabricOverlay.lockAllObjects(false);
                        this._fabricOverlay._fabricCanvas.selection = false;
                        //this must be called. Otherwise points from edit mode won't be removed from canvas.
                        this._fabricOverlay.deselect();
                        break;
                    case this.modes.EDIT:
                        this._fabricOverlay.lockAllObjects(true);
                        this._fabricOverlay.editActiveShape();
                        break
                    case this.modes.GROUP:
                        this._fabricOverlay.lockAllObjects(false);
                        this.viewer.setMouseNavEnabled(false);
                        this._fabricOverlay._fabricCanvas.selection = true;

                        if (!this.fill) {
                            // show button state, always fill at the beginning of group mode
                            this.$.fillMode.toggleChecked()
                            this.fill = true
                        }

                        // always call switchFillMode to change to group colors
                        this._fabricOverlay.switchFillMode(this.fill);
                        break
                    case this.modes.NAVIGATE:
//                        this._fabricOverlay.deselect();
                        this.viewer.setMouseNavEnabled(true);
                        break;
                    default:
                        console.log('mode ', mode, ' is not known');
                }

            }

            addShapesFromAnnotations(annotations) {
                annotations.forEach(annotation => {
                    const attributes = {data: {label: annotation.body[0].value}}
                    annotation.target.forEach(target => {
                        this._fabricOverlay.importSVG(target.selector.value, attributes)
                    })
                })
            }

            _fillMode() {
                if (!this.init) { return }
                this.$.fillMode.toggleChecked()
                this.fill = !this.fill
                this._fabricOverlay.switchFillMode(this.fill);
            }

            _group(e) {
                // this.$.groupMode.toggleChecked()
                // console.log('group keyboard action ', e);
            }

            _noShapeSelected(selectedShape) {
                return selectedShape === null
            }

            _keyHandler(e) {
                const key = e.key;
                console.log('_keyHandler', key);

                switch (key) {
                    case 'i':
                        console.log(this.viewer.tileSource[0].imageToViewportCoordinates(0,0))
                        break
                    case 'g':
                        console.log('grouping mode triggered');
                        this.mode = this.modes.GROUP;
                        this._fabricOverlay.deselect();
                        this._fabricOverlay.addGroup();
                        break;
                    case 'e':
                        console.log('edit mode');
                        if (this._noShapeSelected(this.selectedShape)) { return }
                        this.mode = this.modes.EDIT
                        break;
                    case 'r':
                        console.log('add rectangle');
                        this.mode = this.modes.RECTANGLE
                        break;
                    case 'c':
                        console.log('add circle');
                        this.mode = this.modes.CIRCLE
                        break;
                    case 'p':
                        console.log('add polygon');
                        this.mode = this.modes.POLYGON
                        break;
                    case 's':
                        console.log('select');
                        this.mode = this.modes.SELECT
                        break;
                    case 'n':
                        console.log('navigate');
                        this.mode = this.modes.NAVIGATE
                        break;
                    case 'Escape':
                        this._fabricOverlay.deselect()
                        this.mode = this.modes.SELECT
                        break;
                    case 'Backspace':
                        this._fabricOverlay.remove()
                        this.mode = this.modes.SELECT
                        break;
                    default:
                        console.log('undefined key ', key);

                }
            }

            changeSelectedShapes(attributes) {
                console.log('changeSelectedShapes.label', attributes)
                this._fabricOverlay.changeSelectedShapes(attributes)
            }

        }

        window.customElements.define(ExistdbImageAnnotator.is, ExistdbImageAnnotator);
    </script>
</dom-module>